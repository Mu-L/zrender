<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Text Overflow</title>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.6/build/dat.gui.js"></script>
    <script src="../dist/zrender.js"></script>
    <script src="lib/config.js"></script>
    <SCript src="data/text.js"></SCript>
    <script src="./lib/testHelper.js"></script>
</head>
<body>
    <style>
        html, body, #main {
            width: 100%;
            height: 100%;
            margin: 0;
        }
    </style>
    <div id="main"></div>

    <script>
    var zr = zrender.init(document.getElementById('main'), {
        renderer: window.__ZRENDER__DEFAULT__RENDERER__
    });

    testHelper.initURLStorage();
    const hashAll = testHelper.getAllFromHash();
    const configFromHash = (hashAll && hashAll['obb_collide_state'])
        ? JSON.parse(hashAll['obb_collide_state'])
        : {};

    const config = Object.assign({
        useOBB: true,
        rotation: 0,
        rotation2: 0,
        useDirection: false,
        direction: -Math.PI / 6,
        bidirectional: true,
        useTouchThreshold: false,
        touchThreshold: 0,
        exchangeSize: false,
    }, configFromHash);

    const sizeDefineList = [{
        width: 130,
        height: 400,
    }, {
        width: 100,
        height: 50
    }];

    const rect = new zrender.Rect({
        style: {
            fill: 'green',
            opacity: 0.7
        },
        draggable: true,
        x: (configFromHash.rect || {}).x || 100,
        y: (configFromHash.rect || {}).y || 50
    });
    const rect2 = new zrender.Rect({
        style: {
            fill: 'green',
            opacity: 0.7
        },
        draggable: true,
        x: (configFromHash.rect2 || {}).x || 300,
        y: (configFromHash.rect2 || {}).y || 200
    });
    const rect2Moved = new zrender.Rect({
        silent: true,
        style: {
            stroke: 'green',
            fill: 'none',
            lineDash: 'dotted',
            lineWidth: 1,
            opacity: 0.9
        },
    });
    zr.add(rect);
    zr.add(rect2);
    zr.add(rect2Moved);


    rect.on('drag', update);
    rect2.on('drag', update);

    const line = new zrender.Line({
        shape: {
            x1: 0, y1: 0, x2: 0, y2: 0
        },
        style: {
            lineWidth: 3,
            stroke: 'blue'
        }
    });
    zr.add(line);

    const directionLine = new zrender.Line({
        shape: {
            x1: 0, y1: 0, x2: 0, y2: 0
        },
        style: {
            lineWidth: 2,
            stroke: '#555',
            lineDash: 'dotted',
        }
    });
    zr.add(directionLine);
    const directionText = new zrender.Text({
        style: {
            text: 'When overlapping, the output mtv should parallel to this direction.'
        }
    });
    zr.add(directionText);
    const directionMark = new zrender.Circle({
        shape: {
            r: 5
        },
        style: {
            fill: '#555'
        }
    });
    zr.add(directionMark);

    function update() {
        rect.attr('rotation', config.rotation);
        rect2.attr('rotation', config.rotation2);
        rect2Moved.attr('rotation', config.rotation2);

        let currSizeList = sizeDefineList.slice();
        if (config.exchangeSize) {
            currSizeList.reverse();
        }

        rect.setShape('width', currSizeList[0].width);
        rect.setShape('height', currSizeList[0].height);
        rect2.setShape('width', currSizeList[1].width);
        rect2.setShape('height', currSizeList[1].height);
        rect2Moved.setShape('width', currSizeList[1].width);
        rect2Moved.setShape('height', currSizeList[1].height);

        const mtv = new zrender.Point();
        let overlapped;
        if (config.useOBB) {
            const obb = new zrender.OrientedBoundingRect(
                rect.getBoundingRect(), rect.getComputedTransform()
            );
            const obb2 = new zrender.OrientedBoundingRect(
                rect2.getBoundingRect(), rect2.getComputedTransform()
            );
            let opt = undefined;
            if (config.useDirection) {
                opt = opt || {};
                opt.direction = config.direction;
                opt.bidirectional = config.bidirectional;
            }
            if (config.useTouchThreshold) {
                opt = opt || {};
                opt.touchThreshold = config.touchThreshold;
            }
            overlapped = obb.intersect(obb2, mtv, opt);
        }
        else {
            const bb = rect.getBoundingRect();
            bb.applyTransform(rect.getComputedTransform());
            const bb2 = rect2.getBoundingRect();
            bb2.applyTransform(rect2.getComputedTransform());
            overlapped = bb.intersect(bb2, mtv);
        }

        const center = new zrender.Point(rect.shape.width / 2, rect.shape.height / 2);
        center.transform(rect.getComputedTransform());
        const center2 = new zrender.Point(rect2.shape.width / 2, rect2.shape.height / 2);
        center2.transform(rect2.getComputedTransform());

        line.setShape({
            x1: center2.x, y1: center2.y,
            x2: center2.x + mtv.x, y2: center2.y + mtv.y
        });

        directionLine.ignore = !config.useDirection;
        const directionR = Math.min(zr.getWidth(), zr.getHeight()) / 2;
        directionLine.setShape({
            x1: center.x - directionR * Math.cos(config.direction),
            y1: center.y - directionR * Math.sin(config.direction),
            x2: center.x + directionR * Math.cos(config.direction),
            y2: center.y + directionR * Math.sin(config.direction),
        });
        directionText.ignore = !config.useDirection;
        directionText.attr('x', center.x);
        directionText.attr('y', center.y);
        directionText.attr('rotation', Math.PI - Math.atan2(
            directionLine.shape.y1 - directionLine.shape.y2,
            directionLine.shape.x1 - directionLine.shape.x2,
        ));
        directionMark.attr('x', center.x + 400 * Math.cos(config.direction));
        directionMark.attr('y', center.y + 400 * Math.sin(config.direction));
        directionMark.ignore = !config.useDirection;

        rect.setStyle('fill', overlapped ? 'red' : 'green');
        rect2.setStyle('fill', overlapped ? 'red' : 'green');
        rect2Moved.setStyle('stroke', overlapped ? 'red' : 'green');

        rect2Moved.attr('x', rect2.x + mtv.x);
        rect2Moved.attr('y', rect2.y + mtv.y);

        testHelper.updateToHash(
            'obb_collide_state', JSON.stringify(Object.assign({}, config, {
                rect: {x: rect.x, y: rect.y},
                rect2: {x: rect2.x, y: rect2.y},
            }))
        );

        console.log(mtv);
    }

    const gui = new dat.GUI();
    gui.add(config, 'useOBB').onChange(update);
    gui.add(config, 'rotation', -5, 5).onChange(update);
    gui.add(config, 'rotation2', -5, 5).onChange(update);
    gui.add(config, 'useDirection').onChange(update);
    gui.add(config, 'direction', -5, 5).onChange(update);
    gui.add(config, 'bidirectional', true).onChange(update);
    gui.add(config, 'useTouchThreshold').onChange(update);
    gui.add(config, 'touchThreshold', -10, 10).onChange(update);
    gui.add(config, 'exchangeSize').onChange(update);

    update();
    </script>
</body>
</html>